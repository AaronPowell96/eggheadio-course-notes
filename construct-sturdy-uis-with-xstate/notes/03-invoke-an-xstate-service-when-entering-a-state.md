# Invoke an Xstate Service when Enterine a state

[video link](https://egghead.io/lessons/react-invoke-an-xstate-service-when-entering-a-state)

- We can reuse the `fetchMachine` in either the same component or different components
  - If we plan on reusing this `machine` it is good to plan ahead and decided what logic should be passed in as an argument and what logic should be delegated inside the machine
- When delegating logic to inside the machine, we can achieve this by having the `pending` state `invoke` a service

```js
export const fetchMachine = Machine({
	...

	pending: {
		invoke: {
			src: 'fetchData', ðŸ‘ˆ// can define a service directly
            onDone: { target: 'successful', actions: ['setResults'] },
			onError: { target: 'failed', actions: ['setMessage'] }
		}       ðŸ‘†ðŸ‘† // onDone and onError are both transitions
	}                // they are envents autogenerated by xState
	...

})
```

By delegating this logic to inside the machine itself, `fetchData` is no longer an action, it's a [service](https://xstate.js.org/docs/guides/communication.html).

Because we now `invoke` a `fetchData` as a service, the values stored inside `event` is now represented by a `data` property:

```js
actions: {
  setResults: assign((ctx, event: any) => ({
    results: event.data, ðŸ‘ˆ // update from result to data
  }));
  setMessage: assign((ctx, event: any) => ({
    message: event.data, ðŸ‘ˆ // update from message to data
  }));
}
```

We must also update our `useMachines` to represent the update from `action` to `service`

```js
const [fetchPeopleState, sendToPeopleMachine] = useMachine(fetchMachine, {
  services: { ðŸ‘ˆ// update to services key
    fetchData: (ctx, event) => {
      return fetchPeople().then((r) => r.results);
    },
  },
});
```

**Note:** `services` can return promises, observables, and even other machines.
